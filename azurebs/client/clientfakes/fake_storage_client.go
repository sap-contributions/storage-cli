// Code generated by counterfeiter. DO NOT EDIT.
package clientfakes

import (
	"io"
	"os"
	"sync"
	"time"

	"github.com/cloudfoundry/storage-cli/azurebs/client"
)

type FakeStorageClient struct {
	CopyStub        func(string, string) error
	copyMutex       sync.RWMutex
	copyArgsForCall []struct {
		arg1 string
		arg2 string
	}
	copyReturns struct {
		result1 error
	}
	copyReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRecursiveStub        func(string) error
	deleteRecursiveMutex       sync.RWMutex
	deleteRecursiveArgsForCall []struct {
		arg1 string
	}
	deleteRecursiveReturns struct {
		result1 error
	}
	deleteRecursiveReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadStub        func(string, *os.File) error
	downloadMutex       sync.RWMutex
	downloadArgsForCall []struct {
		arg1 string
		arg2 *os.File
	}
	downloadReturns struct {
		result1 error
	}
	downloadReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureContainerExistsStub        func() error
	ensureContainerExistsMutex       sync.RWMutex
	ensureContainerExistsArgsForCall []struct {
	}
	ensureContainerExistsReturns struct {
		result1 error
	}
	ensureContainerExistsReturnsOnCall map[int]struct {
		result1 error
	}
	ExistsStub        func(string) (bool, error)
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		arg1 string
	}
	existsReturns struct {
		result1 bool
		result2 error
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListStub        func(string) ([]string, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 string
	}
	listReturns struct {
		result1 []string
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	PropertiesStub        func(string) error
	propertiesMutex       sync.RWMutex
	propertiesArgsForCall []struct {
		arg1 string
	}
	propertiesReturns struct {
		result1 error
	}
	propertiesReturnsOnCall map[int]struct {
		result1 error
	}
	SignedUrlStub        func(string, string, time.Duration) (string, error)
	signedUrlMutex       sync.RWMutex
	signedUrlArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 time.Duration
	}
	signedUrlReturns struct {
		result1 string
		result2 error
	}
	signedUrlReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UploadStub        func(io.ReadSeekCloser, string) ([]byte, error)
	uploadMutex       sync.RWMutex
	uploadArgsForCall []struct {
		arg1 io.ReadSeekCloser
		arg2 string
	}
	uploadReturns struct {
		result1 []byte
		result2 error
	}
	uploadReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorageClient) Copy(arg1 string, arg2 string) error {
	fake.copyMutex.Lock()
	ret, specificReturn := fake.copyReturnsOnCall[len(fake.copyArgsForCall)]
	fake.copyArgsForCall = append(fake.copyArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CopyStub
	fakeReturns := fake.copyReturns
	fake.recordInvocation("Copy", []interface{}{arg1, arg2})
	fake.copyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageClient) CopyCallCount() int {
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	return len(fake.copyArgsForCall)
}

func (fake *FakeStorageClient) CopyCalls(stub func(string, string) error) {
	fake.copyMutex.Lock()
	defer fake.copyMutex.Unlock()
	fake.CopyStub = stub
}

func (fake *FakeStorageClient) CopyArgsForCall(i int) (string, string) {
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	argsForCall := fake.copyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageClient) CopyReturns(result1 error) {
	fake.copyMutex.Lock()
	defer fake.copyMutex.Unlock()
	fake.CopyStub = nil
	fake.copyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) CopyReturnsOnCall(i int, result1 error) {
	fake.copyMutex.Lock()
	defer fake.copyMutex.Unlock()
	fake.CopyStub = nil
	if fake.copyReturnsOnCall == nil {
		fake.copyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) Delete(arg1 string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageClient) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeStorageClient) DeleteCalls(stub func(string) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeStorageClient) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageClient) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) DeleteRecursive(arg1 string) error {
	fake.deleteRecursiveMutex.Lock()
	ret, specificReturn := fake.deleteRecursiveReturnsOnCall[len(fake.deleteRecursiveArgsForCall)]
	fake.deleteRecursiveArgsForCall = append(fake.deleteRecursiveArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteRecursiveStub
	fakeReturns := fake.deleteRecursiveReturns
	fake.recordInvocation("DeleteRecursive", []interface{}{arg1})
	fake.deleteRecursiveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageClient) DeleteRecursiveCallCount() int {
	fake.deleteRecursiveMutex.RLock()
	defer fake.deleteRecursiveMutex.RUnlock()
	return len(fake.deleteRecursiveArgsForCall)
}

func (fake *FakeStorageClient) DeleteRecursiveCalls(stub func(string) error) {
	fake.deleteRecursiveMutex.Lock()
	defer fake.deleteRecursiveMutex.Unlock()
	fake.DeleteRecursiveStub = stub
}

func (fake *FakeStorageClient) DeleteRecursiveArgsForCall(i int) string {
	fake.deleteRecursiveMutex.RLock()
	defer fake.deleteRecursiveMutex.RUnlock()
	argsForCall := fake.deleteRecursiveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageClient) DeleteRecursiveReturns(result1 error) {
	fake.deleteRecursiveMutex.Lock()
	defer fake.deleteRecursiveMutex.Unlock()
	fake.DeleteRecursiveStub = nil
	fake.deleteRecursiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) DeleteRecursiveReturnsOnCall(i int, result1 error) {
	fake.deleteRecursiveMutex.Lock()
	defer fake.deleteRecursiveMutex.Unlock()
	fake.DeleteRecursiveStub = nil
	if fake.deleteRecursiveReturnsOnCall == nil {
		fake.deleteRecursiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRecursiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) Download(arg1 string, arg2 *os.File) error {
	fake.downloadMutex.Lock()
	ret, specificReturn := fake.downloadReturnsOnCall[len(fake.downloadArgsForCall)]
	fake.downloadArgsForCall = append(fake.downloadArgsForCall, struct {
		arg1 string
		arg2 *os.File
	}{arg1, arg2})
	stub := fake.DownloadStub
	fakeReturns := fake.downloadReturns
	fake.recordInvocation("Download", []interface{}{arg1, arg2})
	fake.downloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageClient) DownloadCallCount() int {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	return len(fake.downloadArgsForCall)
}

func (fake *FakeStorageClient) DownloadCalls(stub func(string, *os.File) error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = stub
}

func (fake *FakeStorageClient) DownloadArgsForCall(i int) (string, *os.File) {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	argsForCall := fake.downloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageClient) DownloadReturns(result1 error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = nil
	fake.downloadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) DownloadReturnsOnCall(i int, result1 error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = nil
	if fake.downloadReturnsOnCall == nil {
		fake.downloadReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) EnsureContainerExists() error {
	fake.ensureContainerExistsMutex.Lock()
	ret, specificReturn := fake.ensureContainerExistsReturnsOnCall[len(fake.ensureContainerExistsArgsForCall)]
	fake.ensureContainerExistsArgsForCall = append(fake.ensureContainerExistsArgsForCall, struct {
	}{})
	stub := fake.EnsureContainerExistsStub
	fakeReturns := fake.ensureContainerExistsReturns
	fake.recordInvocation("EnsureContainerExists", []interface{}{})
	fake.ensureContainerExistsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageClient) EnsureContainerExistsCallCount() int {
	fake.ensureContainerExistsMutex.RLock()
	defer fake.ensureContainerExistsMutex.RUnlock()
	return len(fake.ensureContainerExistsArgsForCall)
}

func (fake *FakeStorageClient) EnsureContainerExistsCalls(stub func() error) {
	fake.ensureContainerExistsMutex.Lock()
	defer fake.ensureContainerExistsMutex.Unlock()
	fake.EnsureContainerExistsStub = stub
}

func (fake *FakeStorageClient) EnsureContainerExistsReturns(result1 error) {
	fake.ensureContainerExistsMutex.Lock()
	defer fake.ensureContainerExistsMutex.Unlock()
	fake.EnsureContainerExistsStub = nil
	fake.ensureContainerExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) EnsureContainerExistsReturnsOnCall(i int, result1 error) {
	fake.ensureContainerExistsMutex.Lock()
	defer fake.ensureContainerExistsMutex.Unlock()
	fake.EnsureContainerExistsStub = nil
	if fake.ensureContainerExistsReturnsOnCall == nil {
		fake.ensureContainerExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureContainerExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) Exists(arg1 string) (bool, error) {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExistsStub
	fakeReturns := fake.existsReturns
	fake.recordInvocation("Exists", []interface{}{arg1})
	fake.existsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageClient) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakeStorageClient) ExistsCalls(stub func(string) (bool, error)) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = stub
}

func (fake *FakeStorageClient) ExistsArgsForCall(i int) string {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	argsForCall := fake.existsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageClient) ExistsReturns(result1 bool, result2 error) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageClient) ExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageClient) List(arg1 string) ([]string, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListStub
	fakeReturns := fake.listReturns
	fake.recordInvocation("List", []interface{}{arg1})
	fake.listMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageClient) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeStorageClient) ListCalls(stub func(string) ([]string, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeStorageClient) ListArgsForCall(i int) string {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageClient) ListReturns(result1 []string, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageClient) ListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageClient) Properties(arg1 string) error {
	fake.propertiesMutex.Lock()
	ret, specificReturn := fake.propertiesReturnsOnCall[len(fake.propertiesArgsForCall)]
	fake.propertiesArgsForCall = append(fake.propertiesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PropertiesStub
	fakeReturns := fake.propertiesReturns
	fake.recordInvocation("Properties", []interface{}{arg1})
	fake.propertiesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageClient) PropertiesCallCount() int {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	return len(fake.propertiesArgsForCall)
}

func (fake *FakeStorageClient) PropertiesCalls(stub func(string) error) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = stub
}

func (fake *FakeStorageClient) PropertiesArgsForCall(i int) string {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	argsForCall := fake.propertiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageClient) PropertiesReturns(result1 error) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = nil
	fake.propertiesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) PropertiesReturnsOnCall(i int, result1 error) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = nil
	if fake.propertiesReturnsOnCall == nil {
		fake.propertiesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.propertiesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageClient) SignedUrl(arg1 string, arg2 string, arg3 time.Duration) (string, error) {
	fake.signedUrlMutex.Lock()
	ret, specificReturn := fake.signedUrlReturnsOnCall[len(fake.signedUrlArgsForCall)]
	fake.signedUrlArgsForCall = append(fake.signedUrlArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.SignedUrlStub
	fakeReturns := fake.signedUrlReturns
	fake.recordInvocation("SignedUrl", []interface{}{arg1, arg2, arg3})
	fake.signedUrlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageClient) SignedUrlCallCount() int {
	fake.signedUrlMutex.RLock()
	defer fake.signedUrlMutex.RUnlock()
	return len(fake.signedUrlArgsForCall)
}

func (fake *FakeStorageClient) SignedUrlCalls(stub func(string, string, time.Duration) (string, error)) {
	fake.signedUrlMutex.Lock()
	defer fake.signedUrlMutex.Unlock()
	fake.SignedUrlStub = stub
}

func (fake *FakeStorageClient) SignedUrlArgsForCall(i int) (string, string, time.Duration) {
	fake.signedUrlMutex.RLock()
	defer fake.signedUrlMutex.RUnlock()
	argsForCall := fake.signedUrlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorageClient) SignedUrlReturns(result1 string, result2 error) {
	fake.signedUrlMutex.Lock()
	defer fake.signedUrlMutex.Unlock()
	fake.SignedUrlStub = nil
	fake.signedUrlReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageClient) SignedUrlReturnsOnCall(i int, result1 string, result2 error) {
	fake.signedUrlMutex.Lock()
	defer fake.signedUrlMutex.Unlock()
	fake.SignedUrlStub = nil
	if fake.signedUrlReturnsOnCall == nil {
		fake.signedUrlReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.signedUrlReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageClient) Upload(arg1 io.ReadSeekCloser, arg2 string) ([]byte, error) {
	fake.uploadMutex.Lock()
	ret, specificReturn := fake.uploadReturnsOnCall[len(fake.uploadArgsForCall)]
	fake.uploadArgsForCall = append(fake.uploadArgsForCall, struct {
		arg1 io.ReadSeekCloser
		arg2 string
	}{arg1, arg2})
	stub := fake.UploadStub
	fakeReturns := fake.uploadReturns
	fake.recordInvocation("Upload", []interface{}{arg1, arg2})
	fake.uploadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageClient) UploadCallCount() int {
	fake.uploadMutex.RLock()
	defer fake.uploadMutex.RUnlock()
	return len(fake.uploadArgsForCall)
}

func (fake *FakeStorageClient) UploadCalls(stub func(io.ReadSeekCloser, string) ([]byte, error)) {
	fake.uploadMutex.Lock()
	defer fake.uploadMutex.Unlock()
	fake.UploadStub = stub
}

func (fake *FakeStorageClient) UploadArgsForCall(i int) (io.ReadSeekCloser, string) {
	fake.uploadMutex.RLock()
	defer fake.uploadMutex.RUnlock()
	argsForCall := fake.uploadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageClient) UploadReturns(result1 []byte, result2 error) {
	fake.uploadMutex.Lock()
	defer fake.uploadMutex.Unlock()
	fake.UploadStub = nil
	fake.uploadReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageClient) UploadReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.uploadMutex.Lock()
	defer fake.uploadMutex.Unlock()
	fake.UploadStub = nil
	if fake.uploadReturnsOnCall == nil {
		fake.uploadReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.uploadReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteRecursiveMutex.RLock()
	defer fake.deleteRecursiveMutex.RUnlock()
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	fake.ensureContainerExistsMutex.RLock()
	defer fake.ensureContainerExistsMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	fake.signedUrlMutex.RLock()
	defer fake.signedUrlMutex.RUnlock()
	fake.uploadMutex.RLock()
	defer fake.uploadMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorageClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.StorageClient = new(FakeStorageClient)
